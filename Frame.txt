.model tiny
.386
;=================================================

START_LINE  equ 5d
START_COORD equ 5d
START_LEN_X equ 10d
START_LEN_Y equ 5d

CNT_OF_ZOOM equ 3d
ZOOM_FOR_X  equ 8d
ZOOM_FOR_Y  equ 3d

MAX_X    equ 80d
MAX_Y    equ 25d
VIDEOSEG equ 0b800h

DWLGF	 equ 27h	; dark white letter, green fone
WLRF	 equ 04fh	; white letter, red fone

VER	 equ 0bah	; vertival   for frame
HOR	 equ 0cdh	; horizontal for frame
ULC	 equ 0c9h	; up-left    corner
URC	 equ 0bbh	; up-right   corner
DLC	 equ 0c8h	; down-left  corner
DRC 	 equ 0bch	; down-right corner
SPC   	 equ 20h	; space
;=================================================

.govideoseg	macro
		
		mov bx, VIDEOSEG
		mov es, bx
		
		endm

;=================================================
.code
org 100h 

start:
		.govideoseg
		
		mov ah, DWLGF
		mov dl, START_LEN_X - ZOOM_FOR_X	; -8d for resize
		mov dh, START_LEN_Y - ZOOM_FOR_Y	; -3d for resize

		xor si, si			; si = 0
zoom:
		inc si				; si++
		cmp si, CNT_OF_ZOOM			
		jae end_zoom			; if (si >= 3d) goto end_zoom

		add dl, ZOOM_FOR_X		; zoom (x-coord)
		add dh, ZOOM_FOR_Y		; zoom (y-coord)
		
		mov al, ULC			;}
		mov cx, 1d			;|
		mov bh, START_LINE		;| draw up-left symbol
		mov bl, START_COORD		;|
		call Draw_Line			;}
		
		push bx				; "save" bx
		inc bx				; bx++ (coord_x++)
			
		push dx				; "save" dx
		xor dh, dh			; dh = 0
		mov al, HOR			;}-----
		mov cx, dx			;| draw up line
		call Draw_Line			;}-----
		add bx, dx			; bx += dx (coord_x += dx)
		pop dx				; restore dx
		
		mov al, URC			;}-----
		mov cx, 1d			;| draw up-right symbol
		call Draw_Line			;}-----

		pop bx				; restore bx
		inc bh				; go next line
	
		push si				; "save" si
		xor si, si			; si = 0
do_frame:
		inc si				; si++
		push dx				; "save" dx
		mov dl, dh			;}-----
		xor dh, dh			;| change dh and dl to cmp with si
		cmp si, dx			;}-----
		jae end_frame			; if (si >= dx) goto end_frame
		pop dx				; restore dx

		mov al, VER			;}-----
		mov cx, 1d			;| draw left symbol for main part of frame
		call Draw_Line			;}-----

		push bx				; "save" bx
		inc bx				; bx++ (coord_x++)

		push dx				; "save" dx
		xor dh, dh			; dh = 0
		mov al, SPC			;}----- 
		mov cx, dx			;| draw main line
		call Draw_Line			;}-----
		add bx, dx			; bx += dx (ccoed_x += dx)
		pop dx				; restore dx

		mov al, VER			;}-----
		mov cx, 1d			;| draw right symbol for main part of frame
		call Draw_Line			;}-----

		pop bx				; restore bx
		inc bh				; bh++ (coord_y++)
	
		jmp do_frame 			; goto do_frame

end_frame:
		pop dx				; restore dx
		pop si				; restore si
			
		mov al, DLC			;}-----
		mov cx, 1d			;| draw down-left sumbol
		call Draw_Line			;}-----
		push bx				; "save" bx
		inc bx				; bx++ (coord_x++)

		push dx				; "save" dx
		xor dh, dh			; dh = 0
		mov al, HOR			;}-----
		mov cx, dx			;| draw down line
		call Draw_Line			;}-----
		add bx, dx			; bx += dx (coord_x += dx)
		pop dx				; restore dx

		mov al, DRC			;}-----
		mov cx, 1d			;| draw down-right symbol
		call Draw_Line			;}-----
		pop bx				; restore bx
		
		push bx				; "save" bx
		xor bx, bx			; bx = 0
again:
		add bx, 1			; bx++ (counter++)
		push bx				;}-----
		pop bx				;|
		push bx				;|
		pop bx				;| long time commands
		push bx				;| to make delay
		pop bx				;|
		push bx				;|
		pop bx				;}-----
		cmp bx, 15000			;
		jbe again			; if (bx <= 15000) goto again

		pop bx				; restore bx

		jmp zoom			; goto zoom
end_zoom:
		mov bx, (80*(START_LINE + (ZOOM_FOR_Y*CNT_OF_ZOOM-1)/2) + START_COORD + (ZOOM_FOR_X*CNT_OF_ZOOM-1)/2 - 2)*2	; in middle

		mov byte ptr es:[bx], 'D'	; write 'D'
		inc bx				; bx++
		mov byte ptr es:[bx], WLRF
		inc bx				; bx++

		mov byte ptr es:[bx], 'E'	; write 'E'
		inc bx				; bx++
		mov byte ptr es:[bx], WLRF	
		inc bx				; bx++

		mov byte ptr es:[bx], 'D'	; write 'D'
		inc bx				; bx++
		mov byte ptr es:[bx], WLRF

		ret				; exit (0)

;=================================================
; Draw horizontal line
; In:  
; 	AH - color
;	AL - symbol to draw
;	BH - y-coord (line)
;	BL - x-cord (column)
;	CX - length
; Destroy:
;	CX, ES, DI
;	CX = 0
;	ES = VIDEOSEG
;=================================================

Draw_Line	proc
	
		push ax			; "save" ax
		
		mov al, MAX_X
		mul bh			; ax = bh * MAX_X
		add al, bl		; ax += bx
		shl ax, 1		; ax *= 2

		mov di, ax		; di = ax

		pop ax			; restore ax

		rep stosw		; mov es:[di++], ax

		ret			
		endp

end 		start